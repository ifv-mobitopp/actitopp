package edu.kit.ifv.mobitopp.actitopp;


import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * 
 * @author Tim Hilgert
 *
 */
public class HTour
{
	// Enthält alle Attribute, die nicht direkt über Variablen ausgelesen werden können
	private Map<String, Double> attributes;
	
  private HDay day;
  private List<HActivity> activities;
  private int index		= -99;
  private int starttime 	= -1;

   
  /**
   * 
   * Konstruktor
   *   
   * @param parent
   * @param index
   */
  public HTour(HDay parent, int index)
  {
  	assert parent!=null : "Tag nicht initialisiert";
    this.day = parent;
    setIndex(index);  
    this.activities = new ArrayList<HActivity>();
    
    this.attributes = new HashMap<String, Double>();
  }
    

    
  public HDay getDay()
	{
		assert day != null : "Tag nicht initialisiert";
	    return day;
	}
  
  public HWeekPattern getWeekPattern()
  {
  	return getDay().getPattern();
  }
  
  public ActitoppPerson getPerson()
  {
  	return getDay().getPerson();
  }


  public List<HActivity> getActivities()
	{
		assert activities != null : "Aktivitätenliste nicht initialisiert";
	  return activities;
	}

  public void addActivity(HActivity act)
  {
  	assert act.getIndex()!=-99 : "Index der Aktivität nicht initialisiert";
  	boolean actindexexisitiert = false;
  	for (HActivity tmpact : activities)
  	{
  		if (tmpact.getIndex() == act.getIndex()) actindexexisitiert = true;
  	}
  	assert !actindexexisitiert : "Es gibt bereits eine Aktivität mit diesem Index";
  	activities.add(act);
  }

	public int getIndex()
	{
		assert index != -99 : "Index nicht initilialisiert";
	  return index;
	}


	public void setIndex(int index)
	{
	    this.index = index;
	}


	public int getStartTime()
	{
		assert starttime >= 0 : "Startzeit negativ - Startzeit: " + starttime;
	    return starttime;
	}


	public void setStartTime(int chosenStartTime)
	{
		assert chosenStartTime >= 0 : "Startzeit negativ - Startzeit: " + chosenStartTime;
	    this.starttime = chosenStartTime;
	}


	/**
	 * 
	 * Sortierung einer Tourliste nach Index
	 * 
	 * @param list
	 */
	public static void sortTourList(List<HTour> list)
	{
		assert list != null : "Liste zum Sortieren ist leer";
		
	    Collections.sort(list, new Comparator<HTour>()
	    {
	        @Override
	        public int compare(HTour o1, HTour o2)
	        {
	            if(o1.getIndex() < o2.getIndex()) return -1;
	            if(o1.getIndex() > o2.getIndex()) return 1;
	            return 0;
	        }
	    });
	}

	/**
	 * 
	 * Prüft, ob die Tour keine Zeitlücken aufweist, das heißt ob Akt und Wege direkt aneinander gereiht sind
	 * 
	 * @param tour
	 * @return
	 */
	public boolean tourisFreeofGaps()
	{
		boolean gapfree = true;
		HActivity.sortActivityListbyIndices(activities);
		
		for (int i=0 ; i<activities.size()-1; i++)
		{
			HActivity aktuelleakt = activities.get(i);
			HActivity naechsteakt = activities.get(i+1);
			
			if (aktuelleakt.getEndTimeWeekContext() != naechsteakt.getTripStartTimeBeforeActivityWeekContext()) 
			{
				gapfree=false;
			}
		}	
		
		return gapfree;
	}

	@Override
  public String toString()
  {
		String tostring = "";
		if (this.isScheduled())
		{
			tostring = 	getDay().getIndex() + "/" + getIndex() + 
									" Start " + getStartTimeWeekContext() + 
    							" Ende " + getEndTimeWeekContext() + 
    							" Dauer: " + getTourDuration();  
		}
		else
		{
			tostring = 	getDay().getIndex() + "/" + getIndex() + 
									" Start --- " + 
									" Ende --- " +  
									" Dauer: " + getTourDuration(); 
		}
  	return 	tostring;
  }   
	
	/**
   * 
   * Erstellt Startzeiten für jede Aktivität einer bestimmten Tour
   * 
   */
  public void createStartTimesforActivities()
  {
    // ! sorts the list permanently
    HActivity.sortActivityListbyIndices(getActivities());
    
    for (HActivity act : getActivities())
    {
    	// Bei erster Aktivität in Tour wird die Startzeit durch den Beginn der Tour bestimmt
    	if (!act.startTimeisScheduled())
    	{
    		if (act.isActivityFirstinTour())
      	{
      		act.setStartTime(getStartTime() + act.getEstimatedTripTimeBeforeActivity());
      	}
      	// Ansonsten durch das Ende der vorherigen Aktivität
      	else
      	{
      		act.setStartTime(act.getPreviousActivityinTour().getEndTime() + act.getEstimatedTripTimeBeforeActivity());
      	}
    	}
    }
    
    // Prüfe, ob die Tour einen lückenlosen Ablauf hat, das heißt keine Leerzeit zwischen Akt und Wegen
    if (!tourisFreeofGaps()) System.err.println("Tour hat Lücken! " + this); 
  }
  
  
	
	/**
	 * 
	 * Prüft, ob die Startzeit der Tour bereits festgelegt wurde
	 * 
	 * @return
	 */
	public boolean isScheduled()
	{
		return starttime!=-1;
	}
	
	/**
	 * 
	 * Gibt an, ob es sich um die Haupttour des Tages handelt
	 * 
	 * @return
	 */
	public boolean isMainTouroftheDay()
	{
		return this.getIndex()==0;
	}
	


  
  /**
   * 
   * Gibt die Tourduration inkl. default Trip times zurück
   * 
   * @return
   */
  public int getTourDuration()
  {
  	return getActDuration() + getTripDuration();
  }
  
  /**
   * 
   * Gibt die reine Aktivitätenzeit auf der Tour zurück
   * 
   * @return
   */
  public int getActDuration()
  {
    int sum = 0;
    for(HActivity act : activities)
    {       	
      sum += (act.durationisScheduled() ? act.getDuration() : 0);
    }
    
    return sum;
  }
  
  /**
   * 
   * Gibt die reine Wegzeit auf der Tour zurück
   *     
   * @return
   */
  public int getTripDuration()
  {
    int sum = 0;
    for(HActivity act : activities)
    {
    	sum += (act.tripBeforeActivityisScheduled() ? act.getEstimatedTripTimeBeforeActivity() : 0);
    	sum += (act.tripAfterActivityisScheduled() ? act.getEstimatedTripTimeAfterActivity() : 0);    	
    }
    
    return sum;
  }
  
  /**
   * 
   * Gibt die Endzeit der Tour zurück
   * 
   * @return
   */
  public int getEndTime()
  {
  	return getLastActivityInTour().getEndTime() + getLastActivityInTour().getEstimatedTripTimeAfterActivity();
  }

  /**
   * 
   * Gibt explizit die Aktivität mit dem gesuchten Index zurück
   * 
   * @param index
   * @return
   */
  public HActivity getActivity(int index)
  {
  	HActivity indexact = null;
  	for (HActivity activity : getActivities())
  	{
  		if (activity.getIndex()==index)
  		{
  			indexact = activity;
  		}
  	}
  	assert indexact != null : "Aktivität konnte nicht gefunden werden";
  	return indexact;
  	
  }
  
  
  /**
   *
   * Gibt den Index der erste Aktivität der Tour zurück
   * 
   * @return
   */
  public int getLowestActivityIndex()
  {
      int min = +99;
      for(HActivity act : this.activities)
      {
          if(act.getIndex() < min) min = act.getIndex();
      }
      assert min<=0 : "minimaler AktIndex der Tour ist größer 0 - index: " + min;
      return min;
  }
     
  
  /**
  *
  * Gibt den Index der letzten Aktivität der Tour zurück
  * 
  * @return
  */
  public int getHighestActivityIndex()
  {
      int max = -99;
      for(HActivity act : this.activities)
      {
          if(act.getIndex() > max) 
          {
          	max = act.getIndex();
          }
      }
      assert max>=0 : "maximaler AktIndex der Tour ist kleiner 0 - index: " + max;
      return max;
  }

  /**
   * 
   * Gibt die erste Aktivität der Tour zurück
   * 
   * @return
   */
  public HActivity getFirstActivityInTour()
  {
  	return getActivity(getLowestActivityIndex());    	
  }
  
  /**
   * 
   * Gibt die letzte Aktivität der Tour zurück
   * 
   * @return
   */
  public HActivity getLastActivityInTour()
  {
  	return getActivity(getHighestActivityIndex());    	
  }
  
  public int getAmountOfActivities()
  {
  	return getActivities().size();
  }

  
  public int getStartTimeWeekContext()
  {
  	return (1440*getDay().getIndex()) + getStartTime();
  }
  
  public int getEndTimeWeekContext()
  {
  	return (1440*getDay().getIndex()) + getEndTime();
  }


	/**
	 * 
	 * Gibt die vorherige Tour im Pattern zurück
	 * (letzte Tour des Vortags oder vorherige Tour des aktuellen Tags)
	 * 
	 * @return
	 */
	public HTour getPreviousTourinPattern()
	{
		HTour previousTour;
		//Prüfe, ob die Tour die erste Tour des Tages ist
    if (index == day.getLowestTourIndex())
    {
    	// Suche so lange rückwärts, bis ein Tag mit Touren gefunden wird oder es keinen Vortag mehr gibt
    	HDay previousDaywithTour = day;
    	do 
  		{
    		previousDaywithTour = previousDaywithTour.getPreviousDay();	
  			if (previousDaywithTour!=null && !previousDaywithTour.isHomeDay()) break;
  		}
  		while(previousDaywithTour!=null);
    	
    	// Falls kein Vortag mit Tour existiert wird null zurückgegeben
    	if (previousDaywithTour==null)
    	{
    		previousTour = null;
    	}
    	// Andernfalls die letzte Tour des Vortags
    	else
    	{
    		previousTour = previousDaywithTour.getLastTourOfDay();
    	}  	
    }
    // Falls nicht wird die vorherige Tour dieses Tages zurückgegeben
    else
    {
    	previousTour = day.getTour(index-1);
    }
    return previousTour;
	}
	
	/**
	 * 
	 * Gibt die nächste Tour im Pattern zurück
	 * (erste Tour des Folgetags oder nächste Tour des aktuellen Tags)
	 * 
	 * @return
	 */
	public HTour getNextTourinPattern()
	{
		HTour nextTour;
		//Prüfe, ob die Tour die letzte Tour des Tages ist
    if (index == day.getHighestTourIndex())
    {
    	// Suche so lange vorwärts, bis ein Tag mit Touren gefunden wird oder es keinen Folgetag mehr gibt
    	HDay nextDaywithTour = day;
    	do 
  		{
    		nextDaywithTour = nextDaywithTour.getNextDay();	
  			if (nextDaywithTour!=null && !nextDaywithTour.isHomeDay()) break;
  		}
  		while(nextDaywithTour!=null);
    	
    	// Falls kein Folgetag mit Tour existiert wird null zurückgegeben
    	if (nextDaywithTour==null)
    	{
    		nextTour = null;
    	}
    	// Andernfalls die letzte Tour des Vortags
    	else
    	{
    		nextTour = nextDaywithTour.getFirstTourOfDay();
    	}  	
    }
    // Falls nicht wird die nächste Tour dieses Tages zurückgegeben
    else
    {
    	nextTour = day.getTour(index+1);
    }
    return nextTour;
	}

	/**
	 * @param attributes spezifischesAttribut für Map
	 */
	public void addAttributetoMap(String name, Double value) {
		this.attributes.put(name, value);
	}


	/**
	 * @return the attributes
	 */
	public Map<String, Double> getAttributesMap() {
		return attributes;
	}
	
}
